<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Strict PSL Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        body { background: #000; color: #fff; font-family: 'Courier New', monospace; text-align: center; margin: 0; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .btn { padding: 15px 30px; font-size: 18px; cursor: pointer; background: #222; color: #fff; border: 1px solid #555; margin: 5px; font-weight: bold; }
        .btn.active { background: #00ff00; color: #000; border-color: #00ff00; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; background: #333; color: #888; border: 1px solid #444; }
        
        .vid-wrapper { position: relative; width: 640px; margin: 20px auto; border: 2px solid #333; }
        video { width: 100%; display: block; transform: scaleX(-1); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        .guide-box { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 10px; font-size: 16px; text-align: left; border-left: 3px solid #ff0000; }
        .guide-box.good { border-left: 3px solid #00ff00; color: #00ff00; }
        
        .results { display: none; margin-top: 20px; }
        .tier-text { font-family: 'Impact'; font-size: 60px; letter-spacing: 2px; margin: 10px 0; text-shadow: 0 0 10px currentColor; }
        
        .analysis-grid { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .canvas-card { border: 1px solid #333; background: #111; padding: 5px; }
        .breakdown { text-align: left; background: #111; padding: 20px; border-left: 3px solid #444; max-width: 700px; margin: 20px auto; font-size: 14px; }
        
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid #222; padding: 5px 0; }
        .stat-good { color: #00ff00; }
        .stat-bad { color: #ff0000; }
        .stat-mid { color: #ffff00; }
    </style>
</head>
<body>

<div class="container">
    <h1>STRICT PSL ANALYZER</h1>
    
    <div id="setupControls">
        <button id="btnMale" class="btn active" onclick="setGender('male')">MALE</button>
        <button id="btnFemale" class="btn" onclick="setGender('female')">FEMALE</button>
    </div>

    <div id="liveSection">
        <div class="vid-wrapper">
            <video id="inputVideo" playsinline autoplay></video>
            <canvas id="overlayCanvas" class="overlay"></canvas>
            <div id="guideMsg" class="guide-box">INITIALIZING...</div>
        </div>
        <button id="capBtn" class="btn" disabled style="width: 640px; margin-top: 10px;">CAPTURE FRONT</button>
    </div>

    <div id="resultsSection" class="results">
        <div id="finalTier" class="tier-text">CALCULATING...</div>
        <div id="finalScore" style="color: #888; font-size: 20px;"></div>
        
        <div class="analysis-grid">
            <div class="canvas-card"><canvas id="resFront"></canvas></div>
            <div class="canvas-card"><canvas id="resSide"></canvas></div>
        </div>
        
        <div id="detailedStats" class="breakdown"></div>
        <button class="btn" onclick="location.reload()">RESET</button>
    </div>
</div>

<script>
    let gender = 'male';
    let step = 1; // 1=Front, 2=Side
    let frontLandmarks = null;
    let sideLandmarks = null;
    let sideDir = null; // 'left' or 'right'
    let frontImg = null;
    let sideImg = null;
    let currentLandmarks = null;

    const video = document.getElementById('inputVideo');
    const canvas = document.getElementById('overlayCanvas');
    const ctx = canvas.getContext('2d');
    const guideMsg = document.getElementById('guideMsg');
    const capBtn = document.getElementById('capBtn');

    function setGender(g) {
        gender = g;
        document.getElementById('btnMale').className = g==='male'?'btn active':'btn';
        document.getElementById('btnFemale').className = g==='female'?'btn active':'btn';
    }

    // --- MEDIAPIPE SETUP ---
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);

    const camera = new Camera(video, { onFrame: async () => { await faceMesh.send({image: video}); }, width: 640, height: 480 });
    camera.start();

    // --- MAIN LOOP ---
    function onResults(results) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            currentLandmarks = results.multiFaceLandmarks[0];
            
            if (step === 1) analyzeFront(currentLandmarks);
            if (step === 2) analyzeSide(currentLandmarks);
        } else {
            guideMsg.innerText = "NO FACE DETECTED";
            guideMsg.className = "guide-box";
            capBtn.disabled = true;
        }
    }

    // --- STEP 1: FRONT ANALYSIS ---
    function analyzeFront(lm) {
        // 1. Roll (Head Tilt Left/Right)
        // Compare eyes Y level (33 vs 263)
        let eyeSlope = Math.abs(lm[33].y - lm[263].y);
        
        // 2. Yaw (Head Turn Left/Right)
        // Nose (1) center vs Cheeks (234, 454)
        let noseX = lm[1].x;
        let leftDist = Math.abs(noseX - lm[234].x);
        let rightDist = Math.abs(noseX - lm[454].x);
        let yawRatio = leftDist / rightDist;

        // 3. Pitch (Head Tilt Up/Down) - The "Cheat" Detector
        // Forehead (10) to Nose (1) distance vs Nose (1) to Chin (152) distance
        // These ratios define "Facial Thirds" roughly
        let upperH = Math.abs(lm[10].y - lm[1].y);
        let lowerH = Math.abs(lm[1].y - lm[152].y);
        let pitchRatio = upperH / lowerH;

        let error = [];
        if (eyeSlope > 0.03) error.push("TILT HEAD STRAIGHT");
        if (yawRatio > 1.2 || yawRatio < 0.8) error.push("LOOK STRAIGHT AHEAD");
        // Normal pitch ratio is approx 0.65 - 0.85 depending on face
        if (pitchRatio < 0.55) error.push("DON'T TILT HEAD BACK");
        if (pitchRatio > 0.95) error.push("DON'T TILT HEAD DOWN");

        if (error.length > 0) {
            guideMsg.innerText = error[0];
            guideMsg.className = "guide-box";
            ctx.strokeStyle = "red";
            ctx.strokeRect(100, 50, 440, 380);
            capBtn.disabled = true;
        } else {
            guideMsg.innerText = "PERFECT ALIGNMENT";
            guideMsg.className = "guide-box good";
            ctx.strokeStyle = "#00FF00";
            ctx.lineWidth = 3;
            ctx.strokeRect(100, 50, 440, 380);
            capBtn.disabled = false;
        }
    }

    // --- STEP 2: SIDE ANALYSIS ---
    function analyzeSide(lm) {
        let noseX = lm[1].x;
        let leftCheekX = lm[234].x;
        let rightCheekX = lm[454].x;
        
        let distL = Math.abs(noseX - leftCheekX);
        let distR = Math.abs(noseX - rightCheekX);

        let isSide = false;
        let rotation = 0;

        // Determine Direction
        if (distL < distR * 0.3) {
            sideDir = "right_visible";
            rotation = (1 - (distL / (distL+distR))) * 100;
        } else if (distR < distL * 0.3) {
            sideDir = "left_visible";
            rotation = (1 - (distR / (distL+distR))) * 100;
        } else {
            guideMsg.innerText = "TURN HEAD 70° TO SIDE";
            guideMsg.className = "guide-box";
            capBtn.disabled = true;
            return;
        }

        if (rotation > 75 && rotation < 95) {
            // PITCH CHECK (Side View) - Prevent looking down to fake jaw
            // Eye (33/263) should be roughly level with Ear Top (234/454)
            // This is hard to map perfectly, so we use Nose Bridge Verticality
            // Line between 10 (top) and 1 (nose tip) shouldn't be too tilted
            
            guideMsg.innerText = "HOLD STEADY";
            guideMsg.className = "guide-box good";
            ctx.strokeStyle = "#00FF00";
            ctx.lineWidth = 3;
            ctx.strokeRect(50, 50, 540, 380);
            capBtn.disabled = false;
        } else {
            guideMsg.innerText = `TURN MORE (${rotation.toFixed(0)}%)`;
            guideMsg.className = "guide-box";
            capBtn.disabled = true;
        }
    }

    // --- CAPTURE ---
    capBtn.onclick = () => {
        let c = document.createElement('canvas'); c.width=640; c.height=480;
        let cx = c.getContext('2d'); cx.scale(-1,1); cx.drawImage(video, -640,0,640,480);
        
        if (step === 1) {
            frontLandmarks = currentLandmarks;
            frontImg = c;
            step = 2;
            capBtn.innerText = "CAPTURE SIDE";
            capBtn.disabled = true;
        } else {
            sideLandmarks = currentLandmarks;
            sideImg = c;
            calculateFinalScore();
        }
    }

    // --- SCORING ENGINE ---
    function calculateFinalScore() {
        document.getElementById('liveSection').style.display = 'none';
        document.getElementById('resultsSection').style.display = 'block';
        document.getElementById('setupControls').style.display = 'none';

        let f = frontLandmarks;
        let s = sideLandmarks;
        let score = 50; // Start at Average (50/100)
        let log = "";

        // --- 1. FRONT METRICS ---
        
        // A. Canthal Tilt
        // (Outer Eye Y - Inner Eye Y)
        let tilt = (f[33].y - f[133].y);
        let tiltScore = 0;
        if (tilt < -0.015) tiltScore = 15; // Positive
        else if (tilt > 0.01) tiltScore = -10; // Negative
        else tiltScore = 5; // Neutral
        score += tiltScore;
        log += stat("Canthal Tilt", tilt < -0.01 ? "Positive (Hunter)" : "Neutral/Negative", tiltScore);

        // B. Cheek-to-Jaw Ratio
        let cheekW = Math.abs(f[234].x - f[454].x);
        let jawW = Math.abs(f[58].x - f[288].x);
        let ratio = jawW / cheekW;
        let rScore = 0;
        if (gender === 'male') {
            if (ratio >= 0.92) rScore = 15; // Square
            else if (ratio >= 0.85) rScore = 10;
            else if (ratio < 0.8) rScore = -5;
        } else {
            if (ratio < 0.85 && ratio > 0.75) rScore = 15; // V-Taper
            else rScore = 5;
        }
        score += rScore;
        log += stat("Facial Width Ratio", ratio.toFixed(2), rScore);

        // C. Midface Ratio (Compactness)
        // IPD (Interpupillary Dist) vs Midface Height (Eyes to Mouth)
        let ipd = Math.abs(f[468].x - f[473].x);
        let midFace = Math.abs(f[168].y - f[0].y); // Glabella to Upper Lip
        let compactRatio = midFace / ipd;
        let cScore = 0;
        if (compactRatio < 0.95) cScore = 10; // Compact midface
        else if (compactRatio > 1.1) cScore = -10; // Long midface
        score += cScore;
        log += stat("Midface Compactness", compactRatio.toFixed(2), cScore);

        // --- 2. SIDE METRICS ---
        let ear = (sideDir==='left_visible') ? s[234] : s[454];
        let gon = (sideDir==='left_visible') ? s[132] : s[361];
        let chin = s[152];
        
        // D. Gonial Angle (Jaw Angle)
        let ang = angle(ear, gon, chin);
        let aScore = 0;
        if (ang >= 115 && ang <= 128) aScore = 20; // Ideal
        else if (ang < 110) aScore = -5; // Too square (cartoonish)
        else if (ang > 135) aScore = -20; // Recessed/Melted
        score += aScore;
        log += stat("Gonial Angle", Math.floor(ang)+"°", aScore);

        // E. Ramus Height
        // Distance Ear-Gonion vs Nose-Chin
        let ramusH = Math.sqrt(Math.pow(ear.x-gon.x, 2) + Math.pow(ear.y-gon.y, 2));
        let faceH = Math.sqrt(Math.pow(s[1].x-s[152].x, 2) + Math.pow(s[1].y-s[152].y, 2));
        let ramusRatio = ramusH / faceH;
        let ramScore = 0;
        if (ramusRatio > 0.4) ramScore = 15; // Tall Ramus
        else if (ramusRatio < 0.25) ramScore = -10; // Short Ramus
        score += ramScore;
        log += stat("Ramus Height", ramusRatio > 0.35 ? "Tall/Strong" : "Average/Short", ramScore);

        // F. Forward Growth (Chin Projection)
        // Chin X should be relative to Brow X
        // We need to rotate coordinates to be vertical, but simplified:
        // In proper side profile, Chin X should be >= Brow X (relative to nose)
        // Since we mirrored: 
        // Left visible: Chin X < Brow X is bad (Recessed)
        let browX = s[10].x;
        let chinX = s[152].x;
        let noseX = s[1].x;
        let growthScore = 0;
        
        // Normalize direction
        let projected = false;
        if (sideDir === 'left_visible') {
            // Facing Right -> Chin should be greater X than Brow? 
            // 0 is Left, 1 is Right.
            // If facing right, NoseX is highest.
            if (Math.abs(noseX - chinX) < Math.abs(noseX - browX)) projected = true;
        } else {
            if (Math.abs(noseX - chinX) < Math.abs(noseX - browX)) projected = true;
        }
        
        if (projected) growthScore = 15; else growthScore = -15;
        score += growthScore;
        log += stat("Forward Growth", projected ? "Projected" : "Recessed", growthScore);

        // --- FINAL CALC ---
        score = Math.max(1, Math.min(99, score));
        
        let tier = "";
        let color = "";
        
        if (gender === 'male') {
            if (score >= 94) { tier = "TRUE ADAM"; color = "#00FFFF"; }
            else if (score >= 85) { tier = "CHAD"; color = "#00FF00"; }
            else if (score >= 75) { tier = "HTN"; color = "#ADFF2F"; }
            else if (score >= 60) { tier = "MTN"; color = "#FFFF00"; }
            else if (score >= 45) { tier = "LTN"; color = "#FFA500"; }
            else { tier = "SUB 5"; color = "#FF0000"; }
        } else {
            if (score >= 94) { tier = "TRUE EVE"; color = "#FF69B4"; }
            else if (score >= 85) { tier = "STACY"; color = "#FF1493"; }
            else if (score >= 75) { tier = "HTN"; color = "#ADFF2F"; }
            else if (score >= 60) { tier = "MTN"; color = "#FFFF00"; }
            else if (score >= 45) { tier = "LTN"; color = "#FFA500"; }
            else { tier = "SUB 5"; color = "#FF0000"; }
        }

        // RENDER RESULTS
        document.getElementById('finalTier').innerText = tier;
        document.getElementById('finalTier').style.color = color;
        document.getElementById('finalScore').innerText = `RAW SCORE: ${score.toFixed(1)}`;
        document.getElementById('detailedStats').innerHTML = log;

        // Render Canvases
        let cF = document.getElementById('resFront'); cF.width=640; cF.height=480;
        let cXF = cF.getContext('2d'); cXF.drawImage(frontImg, 0, 0);
        drawFrontOverlay(cXF, f);

        let cS = document.getElementById('resSide'); cS.width=640; cS.height=480;
        let cXS = cS.getContext('2d'); cXS.drawImage(sideImg, 0, 0);
        drawSideOverlay(cXS, s);
    }

    function stat(name, val, pts) {
        let c = pts > 0 ? "stat-good" : (pts < 0 ? "stat-bad" : "stat-mid");
        let sign = pts > 0 ? "+" : "";
        return `<div class="stat-row"><span>${name}: <span style="color:white">${val}</span></span><span class="${c}">${sign}${pts}</span></div>`;
    }

    function angle(a, b, c) {
        let ang = (Math.atan2(c.y-b.y, c.x-b.x) - Math.atan2(a.y-b.y, a.x-b.x)) * 180 / Math.PI;
        return Math.abs(ang > 180 ? 360-ang : ang);
    }

    function drawFrontOverlay(ctx, lm) {
        // We have to flip coordinate usage because canvas image is normal but lm is 1-x
        // Actually, since we captured the mirrored video canvas, the image is ALREADY flipped visually.
        // We just need to use (1-x) logic for coordinates to match.
        function l(i1, i2, c) {
            ctx.beginPath(); ctx.moveTo((1-lm[i1].x)*640, lm[i1].y*480);
            ctx.lineTo((1-lm[i2].x)*640, lm[i2].y*480); ctx.strokeStyle=c; ctx.lineWidth=2; ctx.stroke();
        }
        l(33, 133, "yellow"); l(362, 263, "yellow"); // Eyes
        l(234, 454, "green"); // Cheeks
        l(58, 288, "magenta"); // Jaw
    }

    function drawSideOverlay(ctx, lm) {
        let ear = (sideDir==='left_visible') ? 234 : 454;
        let gon = (sideDir==='left_visible') ? 132 : 361;
        let chin = 152;
        
        function l(i1, i2, c) {
            ctx.beginPath(); ctx.moveTo((1-lm[i1].x)*640, lm[i1].y*480);
            ctx.lineTo((1-lm[i2].x)*640, lm[i2].y*480); ctx.strokeStyle=c; ctx.lineWidth=4; ctx.stroke();
        }
        l(ear, gon, "red");
        l(gon, chin, "red");
        
        // Growth line
        ctx.beginPath(); ctx.moveTo((1-lm[10].x)*640, lm[10].y*480);
        ctx.lineTo((1-lm[152].x)*640, lm[152].y*480);
        ctx.strokeStyle="cyan"; ctx.lineWidth=1; ctx.setLineDash([5,5]); ctx.stroke();
    }
</script>
</body>
</html>
