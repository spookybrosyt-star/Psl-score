<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> PSL Analyzer - Visual</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        :root { --primary: #00ff41; --danger: #ff0033; --bg: #0a0a0a; }
        body { background: var(--bg); color: #eee; font-family: 'Consolas', 'Courier New', monospace; margin: 0; overflow: hidden; height: 100vh; display: flex; flex-direction: column; align-items: center; }
        
        /* UI LAYOUT */
        .hud-container { position: relative; width: 100%; max-width: 800px; margin-top: 20px; }
        .video-box { position: relative; width: 100%; border: 1px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.8); background: #000; overflow: hidden; }
        video { width: 100%; display: block; transform: scaleX(-1); opacity: 0.8; }
        canvas.output { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        /* RETICLE & GUIDES */
        .reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 320px; height: 400px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 120px; pointer-events: none; transition: all 0.3s;
        }
        .reticle.locked { border-color: var(--primary); border-style: solid; box-shadow: 0 0 20px rgba(0, 255, 65, 0.2); }
        .reticle.error { border-color: var(--danger); border-style: solid; }

        /* STATUS BAR */
        .status-bar {
            background: #111; border-top: 2px solid #333; padding: 15px; width: 100%;
            display: flex; justify-content: space-between; align-items: center; box-sizing: border-box;
        }
        .status-text { font-size: 18px; font-weight: bold; color: #888; text-transform: uppercase; }
        .progress-container { width: 40%; background: #222; height: 8px; border-radius: 4px; overflow: hidden; }
        .progress-bar { width: 0%; height: 100%; background: var(--primary); transition: width 0.1s linear; }

        .btn {
            background: transparent; border: 1px solid var(--primary); color: var(--primary);
            padding: 10px 25px; font-family: inherit; font-size: 16px; cursor: pointer;
            text-transform: uppercase; font-weight: bold; transition: 0.2s;
        }
        .btn:hover { background: var(--primary); color: #000; }
        .btn:disabled { border-color: #444; color: #444; cursor: not-allowed; background: transparent; }

        /* RESULTS OVERLAY */
        .results-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99; display: none;
            overflow-y: auto; padding: 20px; box-sizing: border-box;
        }
        .header-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333; padding-bottom: 20px; margin-bottom: 20px; }
        .tier-display { font-size: 60px; font-family: 'Impact', sans-serif; letter-spacing: 2px; margin: 0; }
        
        .visual-report { display: flex; justify-content: center; gap: 20px; margin-bottom: 30px; flex-wrap: wrap; }
        .report-card { background: #111; border: 1px solid #333; padding: 10px; width: 400px; }
        .report-canvas { width: 100%; background: #000; border: 1px solid #222; }
        .card-label { text-align: center; color: #888; font-size: 14px; margin-bottom: 5px; text-transform: uppercase; }

        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; max-width: 1000px; margin: 0 auto; }
        .metric-card { background: #111; border-left: 3px solid #333; padding: 15px; }
        .metric-card.good { border-color: var(--primary); }
        .metric-card.bad { border-color: var(--danger); }
        .metric-top { display: flex; justify-content: space-between; font-weight: bold; font-size: 18px; margin-bottom: 5px; }
        .metric-desc { font-size: 12px; color: #666; }
    </style>
</head>
<body>

<div class="hud-container">
    <div class="video-box" id="vidBox">
        <video id="inputVideo" playsinline autoplay></video>
        <canvas id="outputCanvas" class="output"></canvas>
        <div id="reticle" class="reticle"></div>
        <div id="overlayMsg" style="position: absolute; bottom: 20px; width: 100%; text-align: center; font-size: 24px; font-weight: bold; text-shadow: 0 2px 4px #000; display: none;">HOLD STILL</div>
    </div>
    
    <div class="status-bar">
        <div id="statusText" class="status-text">SYSTEM INITIALIZING...</div>
        <div class="progress-container"><div id="progressBar" class="progress-bar"></div></div>
        <button id="actionBtn" class="btn" disabled onclick="handleAction()">WAIT</button>
    </div>
</div>

<div id="resultsModal" class="results-modal">
    <div class="header-row">
        <div>
            <div id="finalTier" class="tier-display">CALCULATING</div>
            <div id="finalScore" style="color: #888; font-size: 20px;">RAW SCORE: 0.0</div>
        </div>
        <button class="btn" onclick="location.reload()">NEW SCAN</button>
    </div>

    <div class="visual-report">
        <div class="report-card">
            <div class="card-label">Front Analysis</div>
            <canvas id="resFront" class="report-canvas"></canvas>
        </div>
        <div class="report-card">
            <div class="card-label">Side Analysis</div>
            <canvas id="resSide" class="report-canvas"></canvas>
        </div>
    </div>

    <div id="metricsGrid" class="metrics-grid"></div>
</div>

<script>
    // CONFIG
    const SCAN_TIME = 6000; // 6 seconds per scan
    
    // STATE
    let state = 'INIT'; 
    let buffer = [];
    let scanStart = 0;
    
    // IMAGE STORAGE
    let frontSnapshot = null;
    let sideSnapshot = null;
    let frontAvgLM = null;
    let sideAvgLM = null;
    let sideDir = 'right'; // which way is user looking?

    // DOM
    const video = document.getElementById('inputVideo');
    const canvas = document.getElementById('outputCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const progressBar = document.getElementById('progressBar');
    const actionBtn = document.getElementById('actionBtn');
    const reticle = document.getElementById('reticle');
    const overlayMsg = document.getElementById('overlayMsg');

    // SETUP MEDIAPIPE
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    faceMesh.onResults(onResults);

    const camera = new Camera(video, { onFrame: async () => { await faceMesh.send({image: video}); }, width: 1280, height: 720 });
    camera.start();

    // LOOP
    function onResults(results) {
        canvas.width = video.videoWidth; canvas.height = video.videoHeight;
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const lm = results.multiFaceLandmarks[0];
            const align = checkAlignment(lm, state);

            // DRAW MESH
            if (state === 'SCAN_FRONT' || state === 'SCAN_SIDE') {
                // Intense scanning visual
                drawConnectors(ctx, lm, FACEMESH_TESSELATION, {color: '#00ff4130', lineWidth: 1}); 
                drawConnectors(ctx, lm, FACEMESH_RIGHT_EYE, {color: '#00ff41', lineWidth: 2});
                drawConnectors(ctx, lm, FACEMESH_LEFT_EYE, {color: '#00ff41', lineWidth: 2});
                drawConnectors(ctx, lm, FACEMESH_FACE_OVAL, {color: '#00ff41', lineWidth: 2});
            } else {
                // Passive visual
                drawConnectors(ctx, lm, FACEMESH_TESSELATION, {color: '#ffffff10', lineWidth: 1});
            }

            // LOGIC
            if (state === 'READY') {
                if (align.ok) {
                    setStatus("SUBJECT LOCKED - READY", "good");
                    actionBtn.disabled = false; actionBtn.innerText = "START SCAN";
                } else {
                    setStatus(align.msg, "bad");
                    actionBtn.disabled = true; actionBtn.innerText = "ALIGN FACE";
                }
            }
            else if (state === 'SCAN_FRONT' || state === 'SCAN_SIDE') {
                if (align.ok) {
                    buffer.push(lm);
                    let progress = (Date.now() - scanStart) / SCAN_TIME;
                    progressBar.style.width = (progress * 100) + "%";
                    overlayMsg.style.display = 'block';
                    overlayMsg.style.color = '#00ff41';
                    overlayMsg.innerText = "HOLD POSE - DO NOT MOVE";

                    if (progress >= 1) finishScan();
                } else {
                    overlayMsg.style.display = 'block';
                    overlayMsg.style.color = '#ff0033';
                    overlayMsg.innerText = align.msg;
                    scanStart += 100; // Penalty
                }
            }
        } else {
            setStatus("NO FACE DETECTED", "bad");
            actionBtn.disabled = true;
        }
        ctx.restore();
    }

    function checkAlignment(lm, s) {
        let yaw = (lm[234].z - lm[454].z); // depth diff
        let tilt = Math.abs(lm[33].y - lm[263].y);
        
        if (s === 'SCAN_SIDE') {
            // Need strong yaw
            if (Math.abs(yaw) < 0.08) return {ok:false, msg:"TURN 90° SIDEWAYS"};
            return {ok:true, msg:"OK"};
        } else {
            // Front
            if (Math.abs(yaw) > 0.05) return {ok:false, msg:"LOOK STRAIGHT"};
            if (tilt > 0.04) return {ok:false, msg:"HEAD STRAIGHT"};
            return {ok:true, msg:"OK"};
        }
    }

    function setStatus(msg, type) {
        statusText.innerText = msg;
        reticle.className = "reticle " + (type === 'good' ? 'locked' : 'error');
        statusText.style.color = type === 'good' ? '#00ff41' : '#ff0033';
    }

    // ACTIONS
    function handleAction() {
        if (state === 'INIT' || state === 'READY') {
            startScan('SCAN_FRONT');
        } else if (state === 'INTERMISSION') {
            startScan('SCAN_SIDE');
        }
    }

    function startScan(newState) {
        state = newState;
        buffer = [];
        scanStart = Date.now();
        actionBtn.style.display = 'none';
        progressBar.style.width = '0%';
    }

    function finishScan() {
        // Capture Snapshot
        let snapCanvas = document.createElement('canvas');
        snapCanvas.width = video.videoWidth; snapCanvas.height = video.videoHeight;
        let snapCtx = snapCanvas.getContext('2d');
        snapCtx.drawImage(video, 0, 0, snapCanvas.width, snapCanvas.height);
        
        // Average Landmarks
        let avg = getAverage(buffer);
        
        if (state === 'SCAN_FRONT') {
            frontSnapshot = snapCanvas;
            frontAvgLM = avg;
            state = 'INTERMISSION';
            actionBtn.style.display = 'block';
            actionBtn.innerText = "START SIDE SCAN";
            overlayMsg.style.display = 'none';
            setStatus("FRONT SAVED. PREPARE SIDE.", "mid");
        } else {
            sideSnapshot = snapCanvas;
            sideAvgLM = avg;
            // Determine side direction based on Z depth of avg
            sideDir = (avg[234].z < avg[454].z) ? 'left' : 'right';
            calculateResults();
        }
    }

    function getAverage(buf) {
        let res = JSON.parse(JSON.stringify(buf[0]));
        for(let i=0; i<478; i++) {
            let x=0, y=0, z=0;
            for(let f of buf) { x+=f[i].x; y+=f[i].y; z+=f[i].z; }
            res[i].x = x/buf.length; res[i].y = y/buf.length; res[i].z = z/buf.length;
        }
        return res;
    }

    // --- ANALYTICS & VISUALIZATION ---
    function calculateResults() {
        document.getElementById('resultsModal').style.display = 'block';
        let f = frontAvgLM;
        let s = sideAvgLM;
        let metrics = [];
        let score = 50;

        // 1. Canthal Tilt
        let eyeL = f[33].y - f[133].y; // Inner - Outer
        let eyeR = f[263].y - f[362].y; // Outer - Inner (Screenspace flipped)
        // Average tilt
        let tilt = (f[133].y - f[33].y + f[362].y - f[263].y) / 2; 
        // Logic: Lower Y is Higher on screen. 
        // If Outer (133/263) is LOWER Y than Inner (33/362), it's PCT.
        // Actually simplest: Inner.y - Outer.y. If Pos, Inner is lower (NCT). If Neg, Inner is higher (PCT).
        // Wait, Y increases downwards. 
        // If Inner(100) - Outer(90) = +10. Inner is lower down. Outer is higher up. (PCT)
        let tVal = (f[33].y - f[133].y); 
        let tScore = tVal > 0.01 ? 15 : (tVal < -0.01 ? -10 : 0);
        score += tScore;
        metrics.push({name:"Canthal Tilt", score:tScore, val: tVal > 0 ? "Positive" : "Negative"});

        // 2. Jaw Ratio
        let jawW = Math.abs(f[58].x - f[288].x);
        let cheekW = Math.abs(f[234].x - f[454].x);
        let jRatio = jawW/cheekW;
        let jScore = jRatio > 0.9 ? 20 : (jRatio < 0.8 ? -10 : 5);
        score += jScore;
        metrics.push({name:"Jaw Width", score:jScore, val: (jRatio*100).toFixed(0)+"%"});

        // 3. Gonial Angle (Side)
        // Adjust indices based on side
        let ear = (sideDir=='left')?s[234]:s[454];
        let gon = (sideDir=='left')?s[177]:s[401]; // approx gonion
        let chin = s[152];
        let ang = angle(ear, gon, chin);
        let gScore = (ang > 110 && ang < 130) ? 20 : -10;
        score += gScore;
        metrics.push({name:"Gonial Angle", score:gScore, val: ang.toFixed(0)+"°"});

        // RENDER UI
        score = Math.min(99, Math.max(10, score));
        let tier = getTier(score);
        document.getElementById('finalTier').innerText = tier.name;
        document.getElementById('finalTier').style.color = tier.color;
        document.getElementById('finalScore').innerText = "RAW SCORE: " + score.toFixed(1);

        renderGrid(metrics);
        
        // DRAW IMAGES
        drawFinalImage('resFront', frontSnapshot, f, 'front');
        drawFinalImage('resSide', sideSnapshot, s, 'side');
    }

    function drawFinalImage(id, img, lm, type) {
        let c = document.getElementById(id);
        c.width = img.width; c.height = img.height;
        let ctx = c.getContext('2d');
        
        // Flip horizontal because we scanned mirrored
        ctx.save();
        ctx.scale(-1, 1);
        ctx.drawImage(img, -c.width, 0);
        ctx.restore();

        // Draw Lines (Remember to flip X coords for drawing on flipped canvas context if we didn't restore)
        // Actually simpler: The image is drawn flipped. The landmarks are normalized 0..1.
        // If we draw landmarks on the *flipped* image context, we need to treat X as (1-x).
        
        ctx.lineWidth = 4;
        
        if (type === 'front') {
            // Draw Jaw
            line(ctx, lm[58], lm[152], '#00ff41');
            line(ctx, lm[152], lm[288], '#00ff41');
            // Draw Tilt
            line(ctx, lm[33], lm[133], '#ffff00'); // L Eye
            line(ctx, lm[362], lm[263], '#ffff00'); // R Eye
        } else {
            // Side Gonial
            let ear = (sideDir=='left')?lm[234]:lm[454];
            let gon = (sideDir=='left')?lm[177]:lm[401];
            let chin = lm[152];
            line(ctx, ear, gon, '#ff0033');
            line(ctx, gon, chin, '#ff0033');
            
            // Projection line
            line(ctx, lm[10], lm[152], '#00ccff', true);
        }
    }

    function line(ctx, p1, p2, color, dash=false) {
        ctx.strokeStyle = color;
        if (dash) ctx.setLineDash([5,5]); else ctx.setLineDash([]);
        ctx.beginPath();
        // Mirror X calculation: (1 - x) * width
        ctx.moveTo((1-p1.x)*canvas.width, p1.y*canvas.height);
        ctx.lineTo((1-p2.x)*canvas.width, p2.y*canvas.height);
        ctx.stroke();
    }

    function angle(a,b,c) {
        let ab = Math.sqrt(Math.pow(b.x-a.x,2)+Math.pow(b.y-a.y,2));
        let bc = Math.sqrt(Math.pow(b.x-c.x,2)+Math.pow(b.y-c.y,2));
        let ac = Math.sqrt(Math.pow(c.x-a.x,2)+Math.pow(c.y-a.y,2));
        return Math.acos((ab*ab + bc*bc - ac*ac)/(2*ab*bc)) * 180/Math.PI;
    }

    function getTier(s) {
        if (s >= 90) return {name: "GODLIKE", color: "#00ffff"};
        if (s >= 80) return {name: "CHAD", color: "#00ff41"};
        if (s >= 60) return {name: "HIGH TIER", color: "#ccff00"};
        if (s >= 40) return {name: "MID TIER", color: "#ffaa00"};
        return {name: "SUB 5", color: "#ff0033"};
    }

    function renderGrid(metrics) {
        let h = "";
        metrics.forEach(m => {
            let c = m.score > 0 ? "good" : (m.score < 0 ? "bad" : "mid");
            h += `<div class="metric-card ${c}">
                <div class="metric-top"><span>${m.name}</span><span>${m.val}</span></div>
                <div class="metric-desc">Impact: ${m.score > 0 ? "+"+m.score : m.score}</div>
            </div>`;
        });
        document.getElementById('metricsGrid').innerHTML = h;
    }

    setTimeout(() => { state='READY'; }, 1000);
</script>
</body>
</html>
