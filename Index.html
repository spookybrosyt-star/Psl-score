<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> PSL Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <style>
        :root { --primary: #00ff41; --danger: #ff0033; --bg: #0a0a0a; --glass: rgba(20, 20, 20, 0.9); }
        body { background: var(--bg); color: #eee; font-family: 'Consolas', 'Courier New', monospace; margin: 0; overflow: hidden; height: 100vh; display: flex; flex-direction: column; align-items: center; }
        
        /* UI LAYOUT */
        .hud-container { position: relative; width: 100%; max-width: 800px; margin-top: 20px; }
        .video-box { position: relative; width: 100%; border: 1px solid #333; box-shadow: 0 0 20px rgba(0,0,0,0.8); background: #000; }
        video { width: 100%; display: block; transform: scaleX(-1); opacity: 0.6; }
        canvas.output { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        
        /* SCANNER OVERLAYS */
        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            opacity: 0; transition: opacity 0.3s;
        }
        .scanning .scan-line { opacity: 1; animation: scanMove 2s infinite linear; }
        @keyframes scanMove { 0% { top: 0; } 50% { top: 100%; } 100% { top: 0; } }

        .reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 300px; height: 380px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 100px;
            pointer-events: none;
            transition: border-color 0.2s;
        }

        /* STATUS & CONTROLS */
        .status-bar {
            background: #111; border-top: 2px solid #333; padding: 15px; width: 100%;
            display: flex; justify-content: space-between; align-items: center;
            box-sizing: border-box;
        }
        .status-text { font-size: 18px; font-weight: bold; color: #888; text-transform: uppercase; }
        .progress-container { width: 50%; background: #222; height: 10px; border-radius: 5px; overflow: hidden; margin: 0 15px; }
        .progress-bar { width: 0%; height: 100%; background: var(--primary); transition: width 0.1s linear; }

        .btn {
            background: transparent; border: 1px solid var(--primary); color: var(--primary);
            padding: 10px 30px; font-family: inherit; font-size: 16px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: all 0.2s;
        }
        .btn:hover { background: var(--primary); color: #000; box-shadow: 0 0 15px var(--primary); }
        .btn:disabled { border-color: #444; color: #444; cursor: not-allowed; box-shadow: none; background: transparent; }

        /* RESULTS SCREEN */
        .results-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 99; display: none;
            overflow-y: auto; padding: 40px; box-sizing: border-box;
        }
        .tier-display { font-size: 80px; font-weight: 900; margin: 0; line-height: 1; text-shadow: 0 0 30px currentColor; font-family: 'Impact', sans-serif; letter-spacing: 2px; text-align: center; }
        .score-display { font-size: 24px; color: #888; margin-bottom: 40px; text-align: center; }
        
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; max-width: 1200px; margin: 0 auto; }
        .metric-card { background: #111; border: 1px solid #333; padding: 20px; }
        .metric-head { display: flex; justify-content: space-between; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .metric-val { font-size: 24px; font-weight: bold; }
        .metric-desc { font-size: 12px; color: #666; margin-top: 5px; }
        
        .good { color: var(--primary); }
        .bad { color: var(--danger); }
        .mid { color: #ffe600; }
    </style>
</head>
<body>

<div class="hud-container">
    <div class="video-box" id="vidBox">
        <video id="inputVideo" playsinline autoplay></video>
        <canvas id="outputCanvas" class="output"></canvas>
        <div class="scan-line"></div>
        <div id="reticle" class="reticle"></div>
    </div>
    
    <div class="status-bar">
        <div id="statusText" class="status-text">INITIALIZING CORE...</div>
        <div class="progress-container"><div id="progressBar" class="progress-bar"></div></div>
        <button id="actionBtn" class="btn" disabled onclick="handleAction()">WAIT</button>
    </div>
    
    <div style="margin-top: 10px; font-size: 12px; color: #555; text-align: center;">
        ENSURE EVEN LIGHTING • REMOVE GLASSES • NEUTRAL EXPRESSION
    </div>
</div>

<div id="resultsModal" class="results-modal">
    <div id="finalTier" class="tier-display">CALCULATING</div>
    <div id="finalScore" class="score-display">0.0</div>
    <div id="metricsGrid" class="metrics-grid"></div>
    <div style="text-align: center; margin-top: 50px;">
        <button class="btn" onclick="location.reload()">RESTART SCAN</button>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const SCAN_DURATION_MS = 8000; // 8 Seconds of pure data
    const STABILITY_THRESHOLD = 2.5; // Lower is stricter
    
    // --- STATE MANAGEMENT ---
    let state = 'INIT'; // INIT, READY, SCAN_FRONT, SCAN_SIDE, PROCESSING, DONE
    let landmarksBuffer = [];
    let gender = 'male'; // Default, can be toggled if UI added, assuming male strictness for now
    let scanStartTime = 0;
    
    // --- DOM ELEMENTS ---
    const video = document.getElementById('inputVideo');
    const canvas = document.getElementById('outputCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const progressBar = document.getElementById('progressBar');
    const actionBtn = document.getElementById('actionBtn');
    const vidBox = document.getElementById('vidBox');
    const reticle = document.getElementById('reticle');

    // --- MEDIAPIPE SETUP ---
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true, // IMPORTANT: Enables Iris tracking and better lips
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    faceMesh.onResults(onResults);

    const camera = new Camera(video, {
        onFrame: async () => { await faceMesh.send({image: video}); },
        width: 1280, height: 720
    });
    camera.start();

    // --- MAIN LOOP ---
    function onResults(results) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // DRAW FACEMESH (Subtle tech overlay)
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const lm = results.multiFaceLandmarks[0];
            
            // Check Pose Stability
            const alignment = checkAlignment(lm, state);
            
            if (state === 'READY') {
                drawMesh(lm, '#333');
                if (alignment.ok) {
                    statusText.innerText = "SUBJECT LOCKED";
                    statusText.style.color = "#00ff41";
                    reticle.style.borderColor = "#00ff41";
                    actionBtn.disabled = false;
                    actionBtn.innerText = "START SCAN";
                } else {
                    statusText.innerText = alignment.msg;
                    statusText.style.color = "#ff0033";
                    reticle.style.borderColor = "#ff0033";
                    actionBtn.disabled = true;
                    actionBtn.innerText = "ALIGN FACE";
                }
            }
            else if (state === 'SCAN_FRONT' || state === 'SCAN_SIDE') {
                drawMesh(lm, '#00ff41'); // Active scan color
                
                if (alignment.ok) {
                    // Accumulate Data
                    landmarksBuffer.push(lm);
                    
                    // Update Progress
                    let elapsed = Date.now() - scanStartTime;
                    let pct = Math.min(100, (elapsed / SCAN_DURATION_MS) * 100);
                    progressBar.style.width = pct + "%";
                    statusText.innerText = `ACQUIRING DATA... ${landmarksBuffer.length} SAMPLES`;
                    statusText.style.color = "#00ff41";

                    if (elapsed >= SCAN_DURATION_MS) {
                        nextState();
                    }
                } else {
                    // Pause Scan if user moves
                    statusText.innerText = "HOLD STEADY - " + alignment.msg;
                    statusText.style.color = "#ffff00";
                    scanStartTime += 50; // Penalty/Pause timer
                }
            }
        } else {
            statusText.innerText = "NO FACE DETECTED";
            actionBtn.disabled = true;
        }
        ctx.restore();
    }

    // --- ALIGNMENT LOGIC ---
    function checkAlignment(lm, currentState) {
        // Roll (Tilt Head Left/Right)
        let eyeSlope = Math.abs(lm[33].y - lm[263].y);
        // Pitch (Tilt Head Up/Down) - Using nose bridge length ratio
        let midFaceY = Math.abs(lm[10].y - lm[1].y); // Forehead to Nose
        let lowerFaceY = Math.abs(lm[1].y - lm[152].y); // Nose to Chin
        let pitchRatio = midFaceY / lowerFaceY;
        // Yaw (Turn Head Left/Right)
        let noseX = lm[1].x;
        let leftCheekDist = Math.abs(noseX - lm[454].x); // Mirror logic
        let rightCheekDist = Math.abs(noseX - lm[234].x);
        let yawRatio = leftCheekDist / (rightCheekDist + 0.001);

        if (currentState === 'SCAN_SIDE') {
            // Check for ~70-90 degree turn
            // For side profile, one eye becomes obscured or very close to edge.
            // Using Nose-to-Cheek ratio. If facing Left (our Right), RightCheekDist becomes small.
            let isSide = (yawRatio > 3.0 || yawRatio < 0.33); 
            if (!isSide) return { ok: false, msg: "TURN TO PROFILE" };
            if (eyeSlope > 0.1) return { ok: false, msg: "FIX TILT" };
            return { ok: true, msg: "OK" };
        } else {
            // FRONT
            if (eyeSlope > 0.03) return { ok: false, msg: "HEAD TILTED" };
            if (yawRatio > 1.25 || yawRatio < 0.8) return { ok: false, msg: "LOOK STRAIGHT" };
            if (pitchRatio < 0.55) return { ok: false, msg: "CHIN DOWN" };
            if (pitchRatio > 0.85) return { ok: false, msg: "CHIN UP" };
            return { ok: true, msg: "OK" };
        }
    }

    // --- CONTROLLER ---
    let frontData = null;
    let sideData = null;

    function handleAction() {
        if (state === 'INIT' || state === 'READY') {
            startScan('SCAN_FRONT');
        } else if (state === 'INTERMISSION') {
            startScan('SCAN_SIDE');
        }
    }

    function startScan(newState) {
        state = newState;
        landmarksBuffer = [];
        scanStartTime = Date.now();
        vidBox.classList.add('scanning');
        actionBtn.style.display = 'none';
    }

    function nextState() {
        vidBox.classList.remove('scanning');
        
        // Process Buffer (Deep Averaging)
        let averagedLM = getAverageLandmarks(landmarksBuffer);
        
        if (state === 'SCAN_FRONT') {
            frontData = averagedLM;
            state = 'INTERMISSION';
            progressBar.style.width = "0%";
            statusText.innerText = "FRONT SCAN COMPLETE";
            actionBtn.style.display = 'block';
            actionBtn.innerText = "START SIDE SCAN";
            actionBtn.disabled = false;
        } else if (state === 'SCAN_SIDE') {
            sideData = averagedLM;
            state = 'PROCESSING';
            calculateResults();
        }
    }

    function getAverageLandmarks(buffer) {
        if (buffer.length === 0) return null;
        let result = [];
        // Initialize
        for (let i = 0; i < 478; i++) { result.push({x:0, y:0, z:0}); }
        
        // Sum
        for (let frame of buffer) {
            for (let i = 0; i < 478; i++) {
                result[i].x += frame[i].x;
                result[i].y += frame[i].y;
                result[i].z += frame[i].z;
            }
        }
        
        // Divide
        for (let i = 0; i < 478; i++) {
            result[i].x /= buffer.length;
            result[i].y /= buffer.length;
            result[i].z /= buffer.length;
        }
        return result;
    }

    // --- ANALYTICS ENGINE ---
    function calculateResults() {
        document.getElementById('resultsModal').style.display = 'block';
        
        let f = frontData;
        let s = sideData;
        let score = 50; // Base
        let metrics = [];

        // 1. CANTHAL TILT (Eyes)
        // 33 (Inner) vs 133 (Outer) - Left Eye
        let innerY = f[133].y; 
        let outerY = f[33].y; // Note: 33 is outer in MP default? Double check indices. 
        // MP: 33=LeftInner, 133=LeftOuter (Wait, MP 33 is actually inner corner of Right eye on screen left). 
        // Let's use Right Eye on face (Screen Left): 362 (Inner), 263 (Outer)
        let eyeIn = f[362].y;
        let eyeOut = f[263].y;
        let tiltDelta = eyeIn - eyeOut; // Positive means Outer is higher (Good)
        let tiltDeg = Math.atan2(tiltDelta, f[263].x - f[362].x) * (180/Math.PI);
        
        // Adjust score
        let tScore = 0;
        if (tiltDelta > 0.015) tScore = 15; // Hunter
        else if (tiltDelta > 0) tScore = 5; // Neutral
        else tScore = -10; // Negative
        score += tScore;
        metrics.push({name: "Canthal Tilt", val: (tiltDelta > 0 ? "+" : "") + "Positive", score: tScore, desc: "Angle of the eyes relative to horizon."});

        // 2. FWHR (Facial Width to Height Ratio)
        // Bizygomatic Width (234-454) / Midface Height (10-152 * factor)
        // Simplified: Width (234-454) / Nasion-Prosthion (Approx 6-13?)
        // Let's use Width (454-234) vs UpperLip-Brow (0-13)
        let width = Math.abs(f[454].x - f[234].x);
        let height = Math.abs(f[10].y - f[152].y);
        let fwhr = width / (height * 0.65); // Adjustment factor for true FWHR approx
        let fScore = 0;
        if (fwhr > 1.9) fScore = 15;
        else if (fwhr > 1.7) fScore = 10;
        else fScore = -5;
        score += fScore;
        metrics.push({name: "FWHR Approx", val: fwhr.toFixed(2), score: fScore, desc: "Facial Width to Height Ratio. >1.8 is dominant."});

        // 3. MIDFACE RATIO (Compactness)
        // IPD (468-473) vs Philtrum Length
        let ipd = Math.abs(f[468].x - f[473].x);
        let midfaceLen = Math.abs(f[168].y - f[0].y);
        let ratio = midfaceLen / ipd;
        let mScore = 0;
        if (ratio < 0.9) mScore = 15; // Compact
        else if (ratio > 1.05) mScore = -10; // Long
        score += mScore;
        metrics.push({name: "Midface Ratio", val: ratio.toFixed(2), score: mScore, desc: "Midface length vs Eye spacing. Lower is generally better."});

        // 4. JAW DEFINITION (Front)
        // Bigonial Width (Jaw) vs Bizygomatic Width (Cheek)
        let jawW = Math.abs(f[58].x - f[288].x);
        let cheekW = Math.abs(f[454].x - f[234].x);
        let jRatio = jawW / cheekW;
        let jScore = 0;
        if (jRatio > 0.9) jScore = 20; // Robust
        else if (jRatio < 0.8) jScore = -10; // Narrow
        else jScore = 5;
        score += jScore;
        metrics.push({name: "Jaw/Cheek Ratio", val: (jRatio*100).toFixed(0)+"%", score: jScore, desc: "Jaw width relative to cheekbones."});

        // 5. SIDE PROFILE: GONIAL ANGLE
        // Ear(234/454), Gonion(172/397 approx), Chin(152)
        // We use buffered side data 's'
        // Detect side
        let sDir = (s[234].z < s[454].z) ? 'left' : 'right'; // Simple depth check
        let earP = (sDir === 'left') ? s[234] : s[454];
        let jawP = (sDir === 'left') ? s[177] : s[401]; // Better gonion landmarks
        let chinP = s[152];
        
        let ang = calculateAngle(earP, jawP, chinP);
        let gScore = 0;
        if (ang > 110 && ang < 130) gScore = 20;
        else if (ang > 140) gScore = -15; // Recessed/Melted
        else gScore = 0;
        score += gScore;
        metrics.push({name: "Gonial Angle", val: ang.toFixed(0)+"°", score: gScore, desc: "Angle of the jawline. 115°-125° is ideal."});

        // RENDER
        score = Math.min(99, Math.max(10, score));
        let tier = getTier(score);
        
        document.getElementById('finalScore').innerText = score.toFixed(1) + " / 100";
        document.getElementById('finalTier').innerText = tier.name;
        document.getElementById('finalTier').style.color = tier.color;
        
        let grid = document.getElementById('metricsGrid');
        grid.innerHTML = "";
        metrics.forEach(m => {
            let color = m.score > 0 ? "good" : (m.score < 0 ? "bad" : "mid");
            grid.innerHTML += `
                <div class="metric-card">
                    <div class="metric-head">
                        <span>${m.name}</span>
                        <span class="${color}">${m.score > 0 ? "+" : ""}${m.score}</span>
                    </div>
                    <div class="metric-val">${m.val}</div>
                    <div class="metric-desc">${m.desc}</div>
                </div>
            `;
        });
    }

    function calculateAngle(a, b, c) {
        let AB = Math.sqrt(Math.pow(b.x-a.x,2) + Math.pow(b.y-a.y,2));
        let BC = Math.sqrt(Math.pow(b.x-c.x,2) + Math.pow(b.y-c.y,2));
        let AC = Math.sqrt(Math.pow(c.x-a.x,2) + Math.pow(c.y-a.y,2));
        return Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB)) * (180/Math.PI);
    }

    function getTier(s) {
        if (s >= 90) return {name: "SUPREME", color: "#00ffff"};
        if (s >= 80) return {name: "CHAD", color: "#00ff41"};
        if (s >= 70) return {name: "HIGH TIER", color: "#ccff00"};
        if (s >= 55) return {name: "MID TIER", color: "#ffaa00"};
        return {name: "SUB 5", color: "#ff0033"};
    }

    function drawMesh(lm, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        drawConnectors(ctx, lm, FACEMESH_TESSELATION, {color: color, lineWidth: 0.5});
    }
    
    // Initial wait for state
    setTimeout(() => { state = 'READY'; }, 1000);

</script>
</body>
</html>
